require('dotenv').config();
const express = require('express');
const mariadb = require('mariadb');
const cors = require('cors');
const path = require('path');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

const app = express();
const PORT = process.env.PORT || 3000;
const JWT_SECRET = process.env.JWT_SECRET || 'coss-secret-key-2024';

// MariaDB ì—°ê²° í’€ ìƒì„±
let pool = null;
if (process.env.DB_HOST) {
    pool = mariadb.createPool({
        host: process.env.DB_HOST,
        user: process.env.DB_USER,
        password: process.env.DB_PASSWORD,
        database: process.env.DB_NAME,
        port: process.env.DB_PORT || 3306,
        connectionLimit: 5
    });
}

// ë¯¸ë“¤ì›¨ì–´
app.use(cors({
    origin: '*',
    methods: ['GET', 'POST', 'PUT', 'DELETE'],
    allowedHeaders: ['Content-Type', 'Authorization']
}));
app.use(express.json());
app.use(express.static('public'));

// ===== ì¸ì¦ ë¯¸ë“¤ì›¨ì–´ =====
const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];
    
    if (!token) {
        return res.status(401).json({ error: 'Access token required' });
    }
    
    jwt.verify(token, JWT_SECRET, (err, user) => {
        if (err) {
            return res.status(403).json({ error: 'Invalid or expired token' });
        }
        req.user = user;
        next();
    });
};

// ===== ì¸ì¦ ê´€ë ¨ ì—”ë“œí¬ì¸íŠ¸ =====

// íšŒì›ê°€ì…
app.post('/api/auth/signup', async (req, res) => {
    const { name, email, password } = req.body;
    
    if (!name || !email || !password) {
        return res.status(400).json({ error: 'ëª¨ë“  í•„ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”' });
    }
    
    if (password.length < 8) {
        return res.status(400).json({ error: 'ë¹„ë°€ë²ˆí˜¸ëŠ” 8ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤' });
    }
    
    let conn;
    try {
        if (!pool) {
            return res.status(500).json({ error: 'Database not configured' });
        }
        
        conn = await pool.getConnection();
        
        // ì´ë©”ì¼ ì¤‘ë³µ í™•ì¸
        const existingUser = await conn.query(
            'SELECT id FROM users WHERE email = ?',
            [email]
        );
        
        if (existingUser.length > 0) {
            return res.status(400).json({ error: 'ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ì´ë©”ì¼ì…ë‹ˆë‹¤' });
        }
        
        // ë¹„ë°€ë²ˆí˜¸ í•´ì‹±
        const hashedPassword = await bcrypt.hash(password, 10);
        
        // ì‚¬ìš©ì ìƒì„±
        const result = await conn.query(
            'INSERT INTO users (name, email, password, created_at) VALUES (?, ?, ?, NOW())',
            [name, email, hashedPassword]
        );
        
        res.status(201).json({ 
            success: true, 
            message: 'íšŒì›ê°€ì…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤' 
        });
        
    } catch (error) {
        console.error('Signup error:', error);
        res.status(500).json({ error: 'íšŒì›ê°€ì… ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤' });
    } finally {
        if (conn) conn.release();
    }
});

// ë¡œê·¸ì¸
app.post('/api/auth/login', async (req, res) => {
    const { email, password, rememberMe } = req.body;
    
    if (!email || !password) {
        return res.status(400).json({ error: 'ì´ë©”ì¼ê³¼ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”' });
    }
    
    let conn;
    try {
        if (!pool) {
            // í…ŒìŠ¤íŠ¸ìš© ì„ì‹œ ë¡œê·¸ì¸
            if (email === 'test@test.com' && password === 'test1234') {
                const token = jwt.sign(
                    { id: 1, email: 'test@test.com', name: 'í…ŒìŠ¤íŠ¸ ì‚¬ìš©ì' },
                    JWT_SECRET,
                    { expiresIn: rememberMe ? '30d' : '24h' }
                );
                
                return res.json({
                    success: true,
                    token,
                    user: { id: 1, email: 'test@test.com', name: 'í…ŒìŠ¤íŠ¸ ì‚¬ìš©ì' }
                });
            }
            return res.status(401).json({ error: 'ì´ë©”ì¼ ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤' });
        }
        
        conn = await pool.getConnection();
        
        // ì‚¬ìš©ì ì¡°íšŒ
        const users = await conn.query(
            'SELECT id, name, email, password FROM users WHERE email = ?',
            [email]
        );
        
        if (users.length === 0) {
            return res.status(401).json({ error: 'ì´ë©”ì¼ ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤' });
        }
        
        const user = users[0];
        
        // ë¹„ë°€ë²ˆí˜¸ í™•ì¸
        const validPassword = await bcrypt.compare(password, user.password);
        if (!validPassword) {
            return res.status(401).json({ error: 'ì´ë©”ì¼ ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤' });
        }
        
        // JWT í† í° ìƒì„±
        const token = jwt.sign(
            { id: user.id, email: user.email, name: user.name },
            JWT_SECRET,
            { expiresIn: rememberMe ? '30d' : '24h' }
        );
        
        // ë§ˆì§€ë§‰ ë¡œê·¸ì¸ ì‹œê°„ ì—…ë°ì´íŠ¸
        await conn.query(
            'UPDATE users SET last_login = NOW() WHERE id = ?',
            [user.id]
        );
        
        res.json({
            success: true,
            token,
            user: {
                id: user.id,
                name: user.name,
                email: user.email
            }
        });
        
    } catch (error) {
        console.error('Login error:', error);
        res.status(500).json({ error: 'ë¡œê·¸ì¸ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤' });
    } finally {
        if (conn) conn.release();
    }
});

// í† í° ê²€ì¦
app.get('/api/auth/verify', authenticateToken, (req, res) => {
    res.json({ 
        success: true, 
        user: req.user 
    });
});

// ===== ì•½ë¬¼ ê´€ë¦¬ ì—”ë“œí¬ì¸íŠ¸ =====

// ì•½ë¬¼ ëª©ë¡ ì¡°íšŒ
app.get('/api/medications', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    
    if (!pool) {
        return res.json({ success: true, data: [] });
    }
    
    let conn;
    try {
        conn = await pool.getConnection();
        const medications = await conn.query(
            `SELECT * FROM medications 
             WHERE user_id = ? AND is_active = 1 
             ORDER BY created_at DESC`,
            [userId]
        );
        
        // ë³µì•½ ì‹œê°„ ì •ë³´ë„ í•¨ê»˜ ì¡°íšŒ
        for (let med of medications) {
            const schedule = await conn.query(
                'SELECT time FROM medication_schedule WHERE medication_id = ? ORDER BY time',
                [med.id]
            );
            med.schedule = schedule.map(s => s.time);
        }
        
        res.json({ success: true, data: medications });
    } catch (error) {
        console.error('Error fetching medications:', error);
        res.status(500).json({ success: false, error: error.message });
    } finally {
        if (conn) conn.release();
    }
});

// ì•½ë¬¼ ì¶”ê°€
app.post('/api/medications', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { name, type, dosage, frequency, schedule, start_date, end_date, notes } = req.body;
    
    if (!pool) {
        return res.json({ success: true, message: 'Medication added (no DB)' });
    }
    
    let conn;
    try {
        conn = await pool.getConnection();
        
        // ì•½ë¬¼ ì •ë³´ ì €ì¥
        const result = await conn.query(
            `INSERT INTO medications 
             (user_id, name, type, dosage, frequency, start_date, end_date, notes, is_active, created_at) 
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, 1, NOW())`,
            [userId, name, type, dosage, frequency, start_date, end_date, notes]
        );
        
        const medicationId = result.insertId;
        
        // ë³µì•½ ì‹œê°„ ì €ì¥
        if (schedule && schedule.length > 0) {
            for (const time of schedule) {
                await conn.query(
                    'INSERT INTO medication_schedule (medication_id, time) VALUES (?, ?)',
                    [medicationId, time]
                );
            }
        }
        
        // ì•Œë¦¼ ìƒì„±
        await createReminders(conn, medicationId, userId, schedule, start_date, end_date);
        
        res.json({ success: true, message: 'ì•½ë¬¼ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤', id: medicationId });
    } catch (error) {
        console.error('Error adding medication:', error);
        res.status(500).json({ success: false, error: error.message });
    } finally {
        if (conn) conn.release();
    }
});

// ë³µì•½ ê¸°ë¡
app.post('/api/medications/:id/take', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const medicationId = req.params.id;
    
    if (!pool) {
        return res.json({ success: true, message: 'Dose recorded (no DB)' });
    }
    
    let conn;
    try {
        conn = await pool.getConnection();
        
        // ë³µì•½ ë¡œê·¸ ì €ì¥
        await conn.query(
            `INSERT INTO medication_logs 
             (user_id, medication_id, timestamp, event_type) 
             VALUES (?, ?, NOW(), 'MANUAL_TAKEN')`,
            [userId, medicationId]
        );
        
        res.json({ success: true, message: 'ë³µì•½ì´ ê¸°ë¡ë˜ì—ˆìŠµë‹ˆë‹¤' });
    } catch (error) {
        console.error('Error recording dose:', error);
        res.status(500).json({ success: false, error: error.message });
    } finally {
        if (conn) conn.release();
    }
});

// ===== ë¦¬í¬íŠ¸ ì—”ë“œí¬ì¸íŠ¸ =====

// ë¦¬í¬íŠ¸ ë°ì´í„° ì¡°íšŒ
app.get('/api/reports', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { start_date, end_date } = req.query;
    
    if (!pool) {
        // ìƒ˜í”Œ ë°ì´í„° ë°˜í™˜
        return res.json({
            success: true,
            pdc: 85,
            mpr: 92,
            cmg: 2,
            consistency: 78,
            predictions: {
                next_week_adherence: 88,
                risk_factors: ['ì£¼ë§ íŒ¨í„´', 'ì €ë… ì‹œê°„ ë³€ë™'],
                recommendations: ['ì•Œë¦¼ ê°•í™”', 'ì‹œê°„ ê³ ì •']
            }
        });
    }
    
    let conn;
    try {
        conn = await pool.getConnection();
        
        // PDC (Proportion of Days Covered) ê³„ì‚°
        const pdcResult = await conn.query(
            `SELECT 
                COUNT(DISTINCT DATE(timestamp)) as covered_days,
                DATEDIFF(CURDATE(), MIN(DATE(timestamp))) + 1 as total_days
             FROM medication_logs 
             WHERE user_id = ? 
             AND timestamp BETWEEN ? AND ?`,
            [userId, start_date || '2024-01-01', end_date || new Date()]
        );
        
        const pdc = pdcResult[0].total_days > 0 
            ? Math.round((pdcResult[0].covered_days / pdcResult[0].total_days) * 100)
            : 0;
        
        // MPR (Medication Possession Ratio) ê³„ì‚°
        const mprResult = await conn.query(
            `SELECT 
                COUNT(*) as doses_taken,
                (SELECT SUM(frequency) FROM medications WHERE user_id = ?) * 
                DATEDIFF(?, ?) as expected_doses
             FROM medication_logs 
             WHERE user_id = ? 
             AND timestamp BETWEEN ? AND ?`,
            [userId, end_date || new Date(), start_date || '2024-01-01', 
             userId, start_date || '2024-01-01', end_date || new Date()]
        );
        
        const mpr = mprResult[0].expected_doses > 0
            ? Math.round((mprResult[0].doses_taken / mprResult[0].expected_doses) * 100)
            : 0;
        
        // CMG (Continuous Measure Gap) ê³„ì‚°
        const gapResult = await conn.query(
            `SELECT MAX(gap_days) as max_gap FROM (
                SELECT 
                    DATEDIFF(
                        DATE(timestamp), 
                        LAG(DATE(timestamp)) OVER (ORDER BY timestamp)
                    ) - 1 as gap_days
                FROM medication_logs 
                WHERE user_id = ?
                AND timestamp BETWEEN ? AND ?
            ) as gaps`,
            [userId, start_date || '2024-01-01', end_date || new Date()]
        );
        
        const cmg = gapResult[0].max_gap || 0;
        
        // ì‹œê°„ ì¼ê´€ì„± ê³„ì‚°
        const consistencyResult = await conn.query(
            `SELECT 
                STD(HOUR(timestamp)) as hour_std,
                AVG(HOUR(timestamp)) as hour_avg
             FROM medication_logs 
             WHERE user_id = ?
             AND timestamp BETWEEN ? AND ?`,
            [userId, start_date || '2024-01-01', end_date || new Date()]
        );
        
        const consistency = consistencyResult[0].hour_std 
            ? Math.max(0, 100 - (consistencyResult[0].hour_std * 10))
            : 100;
        
        res.json({
            success: true,
            pdc: Math.round(pdc),
            mpr: Math.round(mpr),
            cmg: Math.round(cmg),
            consistency: Math.round(consistency),
            predictions: {
                next_week_adherence: Math.round(pdc * 1.03), // ê°„ë‹¨í•œ ì˜ˆì¸¡
                risk_factors: analyzeRiskFactors(consistencyResult[0]),
                recommendations: generateRecommendations(pdc, mpr, consistency)
            }
        });
        
    } catch (error) {
        console.error('Error generating report:', error);
        res.status(500).json({ success: false, error: error.message });
    } finally {
        if (conn) conn.release();
    }
});

// ìœ„í—˜ ìš”ì¸ ë¶„ì„ í•¨ìˆ˜
function analyzeRiskFactors(stats) {
    const factors = [];
    if (stats.hour_std > 2) {
        factors.push('ë³µì•½ì‹œê°„ ë³€ë™ì„± ë†’ìŒ');
    }
    if (stats.hour_avg < 8 || stats.hour_avg > 22) {
        factors.push('ë¹„ì •ìƒì ì¸ ë³µì•½ ì‹œê°„ëŒ€');
    }
    return factors;
}

// ê°œì„  ê¶Œì¥ì‚¬í•­ ìƒì„± í•¨ìˆ˜
function generateRecommendations(pdc, mpr, consistency) {
    const recommendations = [];
    if (pdc < 80) {
        recommendations.push('ì¼ì¼ ì•Œë¦¼ íšŸìˆ˜ ì¦ê°€ ê¶Œì¥');
    }
    if (consistency < 70) {
        recommendations.push('ë³µì•½ ì‹œê°„ ê³ ì • í•„ìš”');
    }
    if (mpr < 90) {
        recommendations.push('ì•½ë¬¼ ì¬ì²˜ë°© ì¼ì • í™•ì¸ í•„ìš”');
    }
    return recommendations;
}

// ì•Œë¦¼ ìƒì„± í•¨ìˆ˜
async function createReminders(conn, medicationId, userId, schedule, startDate, endDate) {
    // ì•Œë¦¼ ìƒì„± ë¡œì§
    for (const time of schedule) {
        await conn.query(
`INSERT INTO reminders               (user_id, medication_id, time, is_active, created_at)               VALUES (?, ?, ?, 1, NOW())`,
            [userId, medicationId, time]
        );
    }
}

// ===== ë³µì•½ ë¡œê·¸ ì—”ë“œí¬ì¸íŠ¸ =====

// ë³µì•½ ë¡œê·¸ ì¡°íšŒ
app.get('/api/medication-logs', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    const { start_date, end_date, limit = 100 } = req.query;
    
    if (!pool) {
        return res.json({ success: true, data: [] });
    }

    let conn;
    try {
        conn = await pool.getConnection();
        let query = `
            SELECT ml.*, m.name as medication_name, m.dosage 
            FROM medication_logs ml
            LEFT JOIN medications m ON ml.medication_id = m.id
            WHERE ml.user_id = ?`;
        const params = [userId];
        
        if (start_date) {
            query += ' AND ml.timestamp >= ?';
            params.push(start_date);
        }
        if (end_date) {
            query += ' AND ml.timestamp <= ?';
            params.push(end_date);
        }
        
        query += ' ORDER BY ml.timestamp DESC LIMIT ?';
        params.push(parseInt(limit));
        
        const logs = await conn.query(query, params);
        res.json({ success: true, data: logs });
    } catch (error) {
        console.error('Error fetching medication logs:', error);
        res.status(500).json({ success: false, error: error.message });
    } finally {
        if (conn) conn.release();
    }
});

// ë³µì•½ í†µê³„ ì¡°íšŒ
app.get('/api/medication-stats', authenticateToken, async (req, res) => {
    const userId = req.user.id;
    
    if (!pool) {
        return res.json({ 
            success: true, 
            data: {
                total_count: 0,
                today_count: 0,
                week_count: 0,
                month_count: 0,
                adherence_rate: 0,
                streak_days: 0
            }
        });
    }

    let conn;
    try {
        conn = await pool.getConnection();
        
        // ì „ì²´ ì¹´ìš´íŠ¸
        const totalResult = await conn.query(
            'SELECT COUNT(*) as count FROM medication_logs WHERE user_id = ?',
            [userId]
        );
        
        // ì˜¤ëŠ˜ ì¹´ìš´íŠ¸
        const todayResult = await conn.query(
            'SELECT COUNT(*) as count FROM medication_logs WHERE user_id = ? AND DATE(timestamp) = CURDATE()',
            [userId]
        );
        
        // ì£¼ê°„ ì¹´ìš´íŠ¸
        const weekResult = await conn.query(
            'SELECT COUNT(*) as count FROM medication_logs WHERE user_id = ? AND timestamp >= DATE_SUB(NOW(), INTERVAL 7 DAY)',
            [userId]
        );
        
        // ì›”ê°„ ì¹´ìš´íŠ¸
        const monthResult = await conn.query(
            'SELECT COUNT(*) as count FROM medication_logs WHERE user_id = ? AND timestamp >= DATE_SUB(NOW(), INTERVAL 30 DAY)',
            [userId]
        );
        
        // ìˆœì‘ë„ ê³„ì‚° (ìµœê·¼ 7ì¼)
        const adherenceResult = await conn.query(
            'SELECT COUNT(DISTINCT DATE(timestamp)) as days FROM medication_logs WHERE user_id = ? AND timestamp >= DATE_SUB(NOW(), INTERVAL 7 DAY)',
            [userId]
        );
        
        // ì—°ì† ë³µì•½ì¼ ê³„ì‚°
        const streakResult = await conn.query(
            `SELECT DATE(timestamp) as date 
             FROM medication_logs 
             WHERE user_id = ?
             GROUP BY DATE(timestamp) 
             ORDER BY date DESC`,
            [userId]
        );
        
        let streak = 0;
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        for (let i = 0; i < streakResult.length; i++) {
            const logDate = new Date(streakResult[i].date);
            const expectedDate = new Date(today);
            expectedDate.setDate(expectedDate.getDate() - i);
            
            if (logDate.toDateString() === expectedDate.toDateString()) {
                streak++;
            } else {
                break;
            }
        }
        
        res.json({
            success: true,
            data: {
                total_count: totalResult[0].count,
                today_count: todayResult[0].count,
                week_count: weekResult[0].count,
                month_count: monthResult[0].count,
                adherence_rate: Math.round((adherenceResult[0].days / 7) * 100),
                streak_days: streak
            }
        });
        
    } catch (error) {
        console.error('Error calculating stats:', error);
        res.status(500).json({ success: false, error: error.message });
    } finally {
        if (conn) conn.release();
    }
});

// ===== IR ì„¼ì„œ ì—”ë“œí¬ì¸íŠ¸ =====

let currentSensorValue = {
    a: 0,
    timestamp: new Date().toISOString(),
    count: 0
};

// ì„¼ì„œê°’ ì¡°íšŒ
app.get('/value', (req, res) => {
    res.json(currentSensorValue);
});

// ì„¼ì„œê°’ ì—…ë°ì´íŠ¸
app.post('/value', async (req, res) => {
    const { a } = req.body;
    const now = new Date();
    
    // ê°ì§€ íšŸìˆ˜ ì¦ê°€ (0->1ë¡œ ë³€ê²½ë  ë•Œë§Œ)
    if (a === 1 && currentSensorValue.a === 0) {
        currentSensorValue.count++;
        
        // ìë™ ë³µì•½ ê¸°ë¡ (ì¶”í›„ ì‚¬ìš©ìë³„ë¡œ êµ¬ë¶„ í•„ìš”)
        if (pool) {
            let conn;
            try {
                conn = await pool.getConnection();
                // í˜„ì¬ëŠ” ëª¨ë“  í™œì„± ì‚¬ìš©ìì—ê²Œ ê¸°ë¡
                await conn.query(
                    'INSERT INTO medication_logs (user_id, timestamp, event_type) VALUES (?, ?, ?)',
                    [1, now, 'SENSOR_DETECTED']
                );
            } catch (error) {
                console.error('Error saving sensor log:', error);
            } finally {
                if (conn) conn.release();
            }
        }
    }

    currentSensorValue.a = a;
    currentSensorValue.timestamp = now.toISOString();

    res.json({ 
        success: true, 
        data: currentSensorValue,
        message: 'Sensor value updated'
    });
});

// ===== ê¸°ë³¸ ì—”ë“œí¬ì¸íŠ¸ =====

// ì •ì  íŒŒì¼ ì„œë¹™
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});
app.get('/dashboard.html', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'dashboard.html'));
});
app.get('/medication.html', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'medication.html'));
});
app.get('/reports.html', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'reports.html'));
});

// ê±´ê°• ì²´í¬
app.get('/health', (req, res) => {
    res.json({
        status: 'ok',
        timestamp: new Date().toISOString(),
        sensorStatus: currentSensorValue,
        dbStatus: pool ? 'connected' : 'not configured'
    });
});

// 404 ì²˜ë¦¬
app.use((req, res) => {
    res.status(404).json({
        error: 'Not Found',
        path: req.url,
        method: req.method
    });
});

// ì—ëŸ¬ ì²˜ë¦¬
app.use((err, req, res, next) => {
    console.error('Error:', err.stack);
    res.status(500).json({
        error: 'Internal Server Error',
        message: err.message
    });
});

// ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™”
async function initDatabase() {
    if (!pool) {
        console.log('Database not configured - running in memory mode');
        return;
    }
    let conn;
    try {
        conn = await pool.getConnection();
        
        // users í…Œì´ë¸”
        await conn.query(`
            CREATE TABLE IF NOT EXISTS users (
                id INT AUTO_INCREMENT PRIMARY KEY,
                name VARCHAR(100) NOT NULL,
                email VARCHAR(100) UNIQUE NOT NULL,
                password VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                last_login TIMESTAMP NULL
            )
        `);
        
        // medications í…Œì´ë¸”
        await conn.query(`
            CREATE TABLE IF NOT EXISTS medications (
                id INT AUTO_INCREMENT PRIMARY KEY,
                user_id INT NOT NULL,
                name VARCHAR(200) NOT NULL,
                type VARCHAR(50),
                dosage VARCHAR(100),
                frequency INT,
                start_date DATE,
                end_date DATE,
                notes TEXT,
                is_active BOOLEAN DEFAULT 1,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                INDEX idx_user_active (user_id, is_active)
            )
        `);
        
        // medication_schedule í…Œì´ë¸”
        await conn.query(`
            CREATE TABLE IF NOT EXISTS medication_schedule (
                id INT AUTO_INCREMENT PRIMARY KEY,
                medication_id INT NOT NULL,
                time TIME NOT NULL,
                FOREIGN KEY (medication_id) REFERENCES medications(id) ON DELETE CASCADE,
                INDEX idx_medication_time (medication_id, time)
            )
        `);
        
        // medication_logs í…Œì´ë¸”
        await conn.query(`
            CREATE TABLE IF NOT EXISTS medication_logs (
                id INT AUTO_INCREMENT PRIMARY KEY,
                user_id INT NOT NULL,
                medication_id INT,
                timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                event_type VARCHAR(50) DEFAULT 'MEDICATION_TAKEN',
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                FOREIGN KEY (medication_id) REFERENCES medications(id) ON DELETE SET NULL,
                INDEX idx_user_timestamp (user_id, timestamp),
                INDEX idx_medication_timestamp (medication_id, timestamp)
            )
        `);
        
        // reminders í…Œì´ë¸”
        await conn.query(`
            CREATE TABLE IF NOT EXISTS reminders (
                id INT AUTO_INCREMENT PRIMARY KEY,
                user_id INT NOT NULL,
                medication_id INT,
                time TIME NOT NULL,
                message TEXT,
                is_active BOOLEAN DEFAULT 1,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                FOREIGN KEY (medication_id) REFERENCES medications(id) ON DELETE CASCADE,
                INDEX idx_user_active (user_id, is_active)
            )
        `);
        
        // sensor_logs í…Œì´ë¸” (ê¸°ì¡´)
        await conn.query(`
            CREATE TABLE IF NOT EXISTS sensor_logs (
                id INT AUTO_INCREMENT PRIMARY KEY,
                box_id VARCHAR(50),
                temperature FLOAT,
                humidity FLOAT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        console.log('âœ… Database tables initialized successfully');
        
    } catch (error) {
        console.error('Error initializing database:', error);
    } finally {
        if (conn) conn.release();
    }
}

// ì„œë²„ ì‹œì‘
app.listen(PORT, async () => {
console.log(â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— â•‘   ğŸš€ COSS Server Started Successfully   â•‘ â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£ â•‘   Port: ${PORT}                           â•‘ â•‘   Environment: ${process.env.NODE_ENV || 'development'}         â•‘ â•‘   Time: ${new Date().toLocaleString()}     â•‘ â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£ â•‘   Enhanced Features:                   â•‘ â•‘   âœ… Advanced Analytics (PDC, MPR)     â•‘ â•‘   âœ… Medication Management             â•‘ â•‘   â± Detailed Reports                  â•‘ â•‘   â± Reminder System                   â•‘ â•‘   â± Pattern Recognition               â•‘ â•‘   â± Predictive Analysis               â•‘ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•    );

    // ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™”
    await initDatabase();
});
